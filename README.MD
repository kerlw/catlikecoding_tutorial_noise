Learning tutorial from catlikecoding.com.

Tutorial: [https://catlikecoding.com/unity/tutorials/pseudorandom-noise/](!https://catlikecoding.com/unity/tutorials/pseudorandom-noise/)

## 1. Hashing ##
From "Window -> Package Manager -> Packages: Unity Registry" install:
* Burst
* Universal RP(Render Pipeline) 

To use URP:
1. Create a folder 'URP', from context menu `Create->Rendering->URP->Pipeline Asset` in this folder.
2. Create `Shader->URP->xxx Shader Graph`

> `Weyl sequence` : frac(i * 0.381f)

```
    
    float v = floor(inResolution * i + 0.00001f);
    

Can't we use an integer division instead of floor here?

Yes, but this isn't a good idea because integer divisions cannot be vectorized, 
which makes our job a lot less efficient. You can verify this by investigating 
the code generated by Burst.

Note that the SSE2 instruction set doesn't include a vectorized floor operation,
so when limited to that instruction set you get four un-vectorized calls to a 
floor function instead, which is suboptimal. Because in this specific case we're 
only dealing with positive values you could also cast to an integer instead, 
which does vectorize with SSE2. But I ignore this to keep things consistent.
```

`Operator override`
1. Turn the static method into a cast-to-uint operator, by replacing the method name with operator uint.
2. Type casting has to be either implicit or explicit.
 
```C#
    public static implicit operator uint (SmallXXHash hash) => hash.accumulator;
```



## 2. Hashing Space ##

## 3. Value Noise ##

## 4. Perlin Noise ##

## 5. Noise Variants ##

## 6. Voronoi Noise ##

## 7. Simplex Noise ##
