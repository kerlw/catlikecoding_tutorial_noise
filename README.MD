Learning tutorial from catlikecoding.com.

Tutorial: [https://catlikecoding.com/unity/tutorials/pseudorandom-noise/](!https://catlikecoding.com/unity/tutorials/pseudorandom-noise/)

## 1. Hashing ##
From "Window -> Package Manager -> Packages: Unity Registry" install:
* Burst
* Universal RP(Render Pipeline) 

To use URP:
1. Create a folder 'URP', from context menu `Create->Rendering->URP->Pipeline Asset` in this folder.
2. Create `Shader->URP->xxx Shader Graph`

> `Weyl sequence` : frac(i * 0.381f)

```
    
    float v = floor(inResolution * i + 0.00001f);
    

Can't we use an integer division instead of floor here?

Yes, but this isn't a good idea because integer divisions cannot be vectorized, 
which makes our job a lot less efficient. You can verify this by investigating 
the code generated by Burst.

Note that the SSE2 instruction set doesn't include a vectorized floor operation,
so when limited to that instruction set you get four un-vectorized calls to a 
floor function instead, which is suboptimal. Because in this specific case we're 
only dealing with positive values you could also cast to an integer instead, 
which does vectorize with SSE2. But I ignore this to keep things consistent.
```

`Operator override`
1. Turn the static method into a cast-to-uint operator, by replacing the method name with operator uint.
2. Type casting has to be either implicit or explicit.
 
```C#
    public static implicit operator uint (SmallXXHash hash) => hash.accumulator;
```



## 2. Hashing Space ##

```C#
            hashesBuffer.SetData(hashes.Reinterpret<uint>(4 * 4));
            positionsBuffer.SetData(positions.Reinterpret<float3>(3 * 4 * 4));
            normalsBuffer.SetData(normals.Reinterpret<float3>(3 * 4 * 4));
```			
> `Can't we directly copy the vectorized data to the compute buffers?`
> Although the CPU and GPU both interpret the compute buffer data in their own way, it turns out that in some situations data misalignment can happen. So we have to make sure that the compute buffers explicitly use the un-vectorized data.

## 3. Value Noise ##

> `How do extension methods work?`
> If you go deep enough, there are no such things as objects. There is just data, some of which represents information and some of which represents instructions. Objects are an abstraction. When invoking a method on an object what really happens is that the CPU pushes some data—the arguments—on a data stack and then jumps to the relevant instructions. The object on which the method was invoked is just another argument. An extension method makes this explicit.

## 4. Perlin Noise ##

## 5. Noise Variants ##

## 6. Voronoi Noise ##

## 7. Simplex Noise ##
